/// <reference types="isaac-typescript-definitions" />
import PocketItemDescription from "../types/PocketItemDescription";
/**
 * PlayerIndex is a specific type of string; see the documentation for the [[`getPlayerIndex`]]
 * function. Mods can signify that data structures handle EntityPlayers by using this type:
 *
 * ```
 * const myPlayerMap = new Map<PlayerIndex, string>();
 * ```
 *
 * This type is branded for extra type safety.
 */
export declare type PlayerIndex = string & {
    __playerIndexBrand: any;
};
/** Iterates over all players and checks if any player is close enough to the specified position. */
export declare function anyPlayerCloserThan(position: Vector, distance: float): boolean;
export declare function anyPlayerHasCollectible(collectibleType: CollectibleType): boolean;
export declare function anyPlayerHasTrinket(trinketType: TrinketType): boolean;
export declare function anyPlayerIs(matchingCharacter: PlayerType): boolean;
export declare function getPlayersOfType(playerType: PlayerType): EntityPlayer[];
export declare function getClosestPlayer(position: Vector): EntityPlayer;
/**
 * Helper function to get the first player with the lowest frame count of 0. Useful to find a
 * freshly spawned player after using items like Esau Jr.
 */
export declare function getNewestPlayer(): EntityPlayer;
/**
 * Returns the slot number corresponding to where a trinket can be safely inserted.
 *
 * Example:
 * ```
 * const player = Isaac.GetPlayer();
 * const trinketSlot = getOpenTrinketSlotNum(player);
 * if (trinketSlot !== null) {
 *   // They have one or more open trinket slots
 *   player.AddTrinket(TrinketType.TRINKET_SWALLOWED_PENNY);
 * }
 * ```
 */
export declare function getOpenTrinketSlot(player: EntityPlayer): int | null;
/**
 * Iterates over all players and checks if any are close enough to the specified position.
 *
 * @returns The first player found when iterating upwards from index 0.
 */
export declare function getPlayerCloserThan(position: Vector, distance: float): EntityPlayer | null;
/**
 * Iterates over every item in the game and returns a map containing the number of each item that
 * the player has.
 */
export declare function getPlayerCollectibleMap(player: EntityPlayer): Map<CollectibleType | int, int>;
export declare function getPlayerFromIndex(playerIndex: PlayerIndex): EntityPlayer | null;
/**
 * This function always excludes players with a non-null parent, since they are not real players
 * (e.g. the Strawman Keeper).
 *
 * @param performExclusions Whether or not to exclude characters that are not directly controlled by
 * the player (i.e. Esau & Tainted Soul). False by default.
 */
export declare function getPlayers(performExclusions?: boolean): EntityPlayer[];
/**
 * Mods often have to track variables relating to the player. In naive mods, information will only
 * be stored about the first player. However, in order to be robust, mods must handle up to 4
 * players playing at the same time. This means that information must be stored on a map data
 * structure. Finding a good index for these types of map data structures is difficult:
 *
 * - We cannot use the index from `Isaac.GetPlayer(i)` since this fails in the case where there are
 *   two players and the first player leaves the run.
 * - We cannot use `EntityPlayer.ControllerIndex` as an index because it fails in the case of Jacob
 *   & Esau or Tainted Forgotten. It also fails in the case of a player changing their controls
 *   mid-run.
 * - We cannot use `EntityPlayer.GetData().index` because it does not persist across saving and
 *   continuing.
 * - We cannot use `GetPtrHash()` as an index because it does not persist across exiting and
 *   relaunching the game.
 *
 * Instead, we use `EntityPlayer.GetCollectibleRNG()` with an arbitrary value of 1 (i.e. Sad Onion).
 * This works even if the player does not have any Sad Onions. We also convert the numerical seed to
 * a string to avoid null element creation when saving the table as JSON (which is necessary when
 * saving variables on run exit).
 *
 * Finally, this index fails in the case of Tainted Lazarus, since the RNG will be the same for both
 * Tainted Lazarus and Dead Tainted Lazarus. We revert to using the RNG of Inner Eye for this case.
 */
export declare function getPlayerIndex(player: EntityPlayer): PlayerIndex;
/** Get the index of this player with respect to the output of the `Isaac.GetPlayer()` function. */
export declare function getPlayerIndexVanilla(playerToFind: EntityPlayer): int | null;
/**
 * Returns the combined value of all of the player's red hearts, soul/black hearts, and bone hearts.
 * This is equivalent to the number of hits that the player can currently take.
 */
export declare function getPlayerNumAllHearts(player: EntityPlayer): int;
/**
 * Use this helper function as a workaround for `EntityPlayer.GetPocketItem()` not working
 * correctly.
 *
 * Note that due to API limitations, there is no way to determine the location of a Dice Bag trinket
 * dice. Furthermore, when the player has a Dice Bag trinket dice and a pocket active at the same
 * time, there is no way to determine the location of the pocket active item. If this function
 * cannot determine the identity of a particular slot, it will mark the type of the slot as
 * `PocketItemType.UNDETERMINABLE`.
 */
export declare function getPocketItems(player: EntityPlayer): PocketItemDescription[];
/**
 * Returns the total number of collectibles amongst all players. For example, if player 1 has 1 Sad
 * Onion and player 2 has 2 Sad Onions, then this function would return 3.
 */
export declare function getTotalPlayerCollectibles(collectibleType: CollectibleType): int;
/** After touching a white fire, a player will turn into The Lost until they clear a room. */
export declare function hasLostCurse(player: EntityPlayer): boolean;
/**
 * Returns whether or not the player can hold an additional active item, beyond what they are
 * currently carrying. This takes the Schoolbag into account.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export declare function hasOpenActiveItemSlot(player: EntityPlayer): boolean;
/**
 * Returns whether or not the player can hold an additional pocket item, beyond what they are
 * currently carrying. This takes into account items that modify the max number of pocket items,
 * like Starter Deck.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export declare function hasOpenPocketItemSlot(player: EntityPlayer): boolean;
/**
 * Returns whether or not the player can hold an additional trinket, beyond what they are currently
 * carrying. This takes into account items that modify the max number of trinkets, like Mom's Purse.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export declare function hasOpenTrinketSlot(player: EntityPlayer): boolean;
/**
 * Some players are "child" players, meaning that they have a non-null Parent property.
 * (For example, the Strawman Keeper.)
 */
export declare function isChildPlayer(player: EntityPlayer): boolean;
export declare function isFirstPlayer(player: EntityPlayer): boolean;
/**
 * Helper function for detecting when a player is Jacob or Esau. This will only match the
 * non-tainted versions of these characters.
 */
export declare function isJacobOrEsau(player: EntityPlayer): boolean;
/** Helper function for detecting when a player is Keeper or Tainted Keeper. */
export declare function isKeeper(player: EntityPlayer): boolean;
export declare function removeDeadEyeMultiplier(player: EntityPlayer): void;
