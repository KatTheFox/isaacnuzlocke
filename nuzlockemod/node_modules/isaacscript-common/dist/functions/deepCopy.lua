--[[ Generated with https://github.com/TypeScriptToLua/TypeScriptToLua ]]
require("lualib_bundle");
local ____exports = {}
local ____constants = require("constants")
local TSTL_MAP_BRAND = ____constants.TSTL_MAP_BRAND
local TSTL_OBJECT_WITH_NUMBER_KEYS_BRAND = ____constants.TSTL_OBJECT_WITH_NUMBER_KEYS_BRAND
local TSTL_SET_BRAND = ____constants.TSTL_SET_BRAND
local VECTOR_BRAND = ____constants.VECTOR_BRAND
local ____debug = require("debug")
local DEBUG = ____debug.DEBUG
local ____log = require("functions.log")
local log = ____log.log
local ____util = require("functions.util")
local isSerializedVector = ____util.isSerializedVector
local isVector = ____util.isVector
local isBrand, deepCopyValue, copyVector, checkMetatable, validateValue
function ____exports.deepCopy(self, oldObject, serializationType, traversalDescription)
    if serializationType == nil then
        serializationType = ____exports.SerializationType.NONE
    end
    if traversalDescription == nil then
        traversalDescription = ""
    end
    local oldObjectType = type(oldObject)
    if oldObjectType ~= "table" then
        error(("The deepCopy function was given a " .. oldObjectType) .. " instead of a table.")
    end
    if DEBUG then
        local logString = "deepCopy is operating on: " .. traversalDescription
        if serializationType == ____exports.SerializationType.SERIALIZE then
            logString = logString .. " (serializing)"
        elseif serializationType == ____exports.SerializationType.DESERIALIZE then
            logString = logString .. " (deserializing)"
        end
        log(nil, logString)
    end
    local isTSTLMap = __TS__InstanceOf(oldObject, Map)
    local isTSTLSet = __TS__InstanceOf(oldObject, Set)
    local hasTSTLMapBrand = false
    local hasTSTLSetBrand = false
    if (not isTSTLMap) and (not isTSTLSet) then
        local oldTable = oldObject
        checkMetatable(nil, oldTable, traversalDescription)
        hasTSTLMapBrand = oldTable[TSTL_MAP_BRAND] ~= nil
        hasTSTLSetBrand = oldTable[TSTL_SET_BRAND] ~= nil
    end
    local newObject
    if ((serializationType == ____exports.SerializationType.NONE) and __TS__InstanceOf(oldObject, Map)) or ((serializationType == ____exports.SerializationType.DESERIALIZE) and hasTSTLMapBrand) then
        newObject = __TS__New(Map)
    elseif ((serializationType == ____exports.SerializationType.NONE) and __TS__InstanceOf(oldObject, Set)) or ((serializationType == ____exports.SerializationType.DESERIALIZE) and hasTSTLSetBrand) then
        newObject = __TS__New(Set)
    else
        newObject = {}
    end
    if serializationType == ____exports.SerializationType.SERIALIZE then
        local newTable = newObject
        if __TS__InstanceOf(oldObject, Map) then
            newTable[TSTL_MAP_BRAND] = ""
        elseif __TS__InstanceOf(oldObject, Set) then
            newTable[TSTL_SET_BRAND] = ""
        end
    end
    if __TS__InstanceOf(oldObject, Map) then
        for ____, ____value in __TS__Iterator(oldObject) do
            local key
            key = ____value[1]
            local value
            value = ____value[2]
            do
                if isBrand(nil, key) then
                    goto __continue15
                end
                deepCopyValue(nil, oldObject, newObject, key, value, traversalDescription, serializationType)
            end
            ::__continue15::
        end
    elseif __TS__InstanceOf(oldObject, Set) then
        for ____, key in __TS__Iterator(oldObject) do
            do
                if isBrand(nil, key) then
                    goto __continue18
                end
                local value = ""
                deepCopyValue(nil, oldObject, newObject, key, value, traversalDescription, serializationType)
            end
            ::__continue18::
        end
    else
        for key, value in pairs(oldObject) do
            do
                if isBrand(nil, key) then
                    goto __continue21
                end
                deepCopyValue(nil, oldObject, newObject, key, value, traversalDescription, serializationType)
            end
            ::__continue21::
        end
    end
    return newObject
end
function isBrand(self, key)
    return (((key == TSTL_MAP_BRAND) or (key == TSTL_SET_BRAND)) or (key == TSTL_OBJECT_WITH_NUMBER_KEYS_BRAND)) or (key == VECTOR_BRAND)
end
function deepCopyValue(self, oldObject, newObject, key, value, traversalDescription, serializationType)
    local valueType = type(value)
    validateValue(nil, value, valueType, traversalDescription)
    local convertNumberKeysToString = false
    local isTSTLObject = __TS__InstanceOf(oldObject, Map) or __TS__InstanceOf(oldObject, Set)
    local keyType = type(key)
    if ((serializationType == ____exports.SerializationType.SERIALIZE) and isTSTLObject) and (keyType == "number") then
        convertNumberKeysToString = true
        local newTable = newObject
        newTable[TSTL_OBJECT_WITH_NUMBER_KEYS_BRAND] = true
        if DEBUG then
            log(nil, "deepCopy is converting a TSTL map with number keys to strings.")
        end
    end
    local newValue
    if isVector(nil, value) then
        local vector = value
        newValue = copyVector(nil, vector, serializationType)
    elseif isSerializedVector(nil, value) and (serializationType == ____exports.SerializationType.DESERIALIZE) then
        local serializedVector = value
        newValue = ____exports.deserializeVector(nil, serializedVector)
    elseif valueType == "table" then
        local ____table = value
        traversalDescription = ____exports.addTraversalDescription(nil, key, traversalDescription)
        newValue = ____exports.deepCopy(nil, ____table, serializationType, traversalDescription)
    elseif convertNumberKeysToString then
        newValue = tostring(value)
    else
        newValue = value
    end
    if __TS__InstanceOf(newObject, Map) then
        newObject:set(key, newValue)
    elseif __TS__InstanceOf(newObject, Set) then
        newObject:add(key)
    else
        newObject[key] = newValue
    end
end
function copyVector(self, vector, serializationType)
    if serializationType == ____exports.SerializationType.SERIALIZE then
        local vectorTable = {}
        vectorTable.X = tostring(vector.X)
        vectorTable.Y = tostring(vector.Y)
        vectorTable[VECTOR_BRAND] = ""
        return vectorTable
    end
    local newVector = Vector(vector.X, vector.Y)
    return newVector
end
function ____exports.deserializeVector(self, vectorTable)
    local xString = vectorTable.X
    local x = tonumber(xString)
    if x == nil then
        error("Failed to read the X value of a serialized vector.")
    end
    local yString = vectorTable.Y
    local y = tonumber(yString)
    if y == nil then
        error("Failed to read the Y value of a serialized vector.")
    end
    return Vector(x, y)
end
function checkMetatable(self, ____table, traversalDescription)
    local metatable = getmetatable(____table)
    if metatable == nil then
        return
    end
    local tableDescription = ((traversalDescription == "") and "the table to copy") or (("\"" .. traversalDescription) .. "\"")
    error(("The deepCopy function detected that " .. tableDescription) .. " has a metatable. Copying tables with metatables is not supported (unless they are TypeScriptToLua Maps).")
end
function validateValue(self, value, valueType, traversalDescription)
    if isVector(nil, value) then
        return
    end
    if (((valueType == "function") or (valueType == "nil")) or (valueType == "thread")) or (valueType == "userdata") then
        error(((("The deepCopy function detected that \"" .. traversalDescription) .. "\" is type ") .. valueType) .. ", which is not supported.")
    end
end
function ____exports.addTraversalDescription(self, key, traversalDescription)
    if traversalDescription ~= "" then
        traversalDescription = traversalDescription .. " --> "
    end
    traversalDescription = traversalDescription .. tostring(key)
    return traversalDescription
end
____exports.SerializationType = SerializationType or ({})
____exports.SerializationType.NONE = 0
____exports.SerializationType[____exports.SerializationType.NONE] = "NONE"
____exports.SerializationType.SERIALIZE = 1
____exports.SerializationType[____exports.SerializationType.SERIALIZE] = "SERIALIZE"
____exports.SerializationType.DESERIALIZE = 2
____exports.SerializationType[____exports.SerializationType.DESERIALIZE] = "DESERIALIZE"
return ____exports
