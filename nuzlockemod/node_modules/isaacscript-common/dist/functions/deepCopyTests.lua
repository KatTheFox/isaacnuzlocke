--[[ Generated with https://github.com/TypeScriptToLua/TypeScriptToLua ]]
require("lualib_bundle");
local ____exports = {}
local ____array = require("functions.array")
local arrayEquals = ____array.arrayEquals
local ____deepCopy = require("functions.deepCopy")
local deepCopy = ____deepCopy.deepCopy
local ____log = require("functions.log")
local log = ____log.log
local copiedObjectIsTable, copiedObjectHasKeyAndValueString, copiedTableHasKeyAndValueNumber, copiedTableDoesNotCoerceTypes, copiedObjectHasNoReferencesForPrimitivesForward, copiedObjectHasNoReferencesForPrimitivesBackward, copiedObjectHasNoReferencesForArray, copiedObjectHasChildObject, copiedMapIsMap, copiedMapHasValue, copiedSetIsSet, copiedSetHasValue, copiedMapHasChildMap
function copiedObjectIsTable(self)
    local oldObject = {abc = "def"}
    local newObject = deepCopy(nil, oldObject)
    local newObjectType = type(newObject)
    if newObjectType ~= "table" then
        error("The copied object is not a table.")
    end
end
function copiedObjectHasKeyAndValueString(self)
    local keyToLookFor = "abc"
    local valueToLookFor = "def"
    local oldObject = {abc = valueToLookFor}
    local newTable = deepCopy(nil, oldObject)
    local newObject = newTable
    local value = newObject[keyToLookFor]
    if value == nil then
        error("The copied object did not have a key of: " .. keyToLookFor)
    end
    local valueType = type(value)
    if valueType ~= "string" then
        error("The copied object had a value type of: " .. valueType)
    end
    if value ~= valueToLookFor then
        error("The copied object had a value of: " .. value)
    end
end
function copiedTableHasKeyAndValueNumber(self)
    local keyToLookFor = 123
    local valueToLookFor = 456
    local oldTable = {}
    oldTable[keyToLookFor] = valueToLookFor
    local newObject = deepCopy(nil, oldTable)
    local newTable = newObject
    local value = newTable[keyToLookFor]
    if value == nil then
        error(
            "The copied object did not have a key of: " .. tostring(keyToLookFor)
        )
    end
    local valueType = type(value)
    if valueType ~= "number" then
        error("The copied object had a value type of: " .. valueType)
    end
    if value ~= valueToLookFor then
        error(
            "The copied object had a value of: " .. tostring(value)
        )
    end
end
function copiedTableDoesNotCoerceTypes(self)
    local keyToLookFor = 123
    local valueToLookFor = 456
    local oldTable = {}
    oldTable[keyToLookFor] = valueToLookFor
    local newObject = deepCopy(nil, oldTable)
    local newTable = newObject
    local keyString = tostring(keyToLookFor)
    local valueString = tostring(valueToLookFor)
    local valueFromString = newTable[keyString]
    if valueFromString ~= nil then
        error("The copied object had a string key of: " .. keyString)
    end
    local value = newTable[keyToLookFor]
    if value == valueString then
        error("The copied object had a value that incorrectly matched the string of: " .. valueString)
    end
end
function copiedObjectHasNoReferencesForPrimitivesForward(self)
    local originalStringValue = "abcdef"
    local originalNumberValue = 123
    local oldObject = {abc = originalStringValue, def = originalNumberValue}
    local newTable = deepCopy(nil, oldObject)
    local newObject = newTable
    oldObject.abc = "newValue"
    if oldObject.abc == newObject.abc then
        error("The copied object has a string reference going forward.")
    end
    oldObject.def = 456
    if oldObject.def == newObject.def then
        error("The copied object has a number reference going forward.")
    end
end
function copiedObjectHasNoReferencesForPrimitivesBackward(self)
    local originalStringValue = "abcdef"
    local originalNumberValue = 123
    local oldObject = {abc = originalStringValue, def = originalNumberValue}
    local newTable = deepCopy(nil, oldObject)
    local newObject = newTable
    newObject.abc = "newValue"
    if newObject.abc == oldObject.abc then
        error("The copied object has a string reference going backward.")
    end
    newObject.def = 456
    if newObject.def == oldObject.def then
        error("The copied object has a number reference going backward.")
    end
end
function copiedObjectHasNoReferencesForArray(self)
    local oldObject = {abc = {1, 2, 3}}
    local newTable = deepCopy(nil, oldObject)
    local newObject = newTable
    if oldObject.abc == newObject.abc then
        error("The copied object has the same point to the child array.")
    end
    if not arrayEquals(nil, oldObject.abc, newObject.abc) then
        error("The copied object does not have an equal array.")
    end
    local ____obj, ____index = oldObject.abc, 0 + 1
    ____obj[____index] = ____obj[____index] + 1
    if arrayEquals(nil, oldObject.abc, newObject.abc) then
        error("The copied object has an equal array after a modification to the old array.")
    end
    local ____obj, ____index = oldObject.abc, 0 + 1
    ____obj[____index] = ____obj[____index] - 1
    local ____obj, ____index = newObject.abc, 0 + 1
    ____obj[____index] = ____obj[____index] + 1
    if arrayEquals(nil, oldObject.abc, newObject.abc) then
        error("The copied object has an equal array after a modification to the new array.")
    end
    local ____obj, ____index = newObject.abc, 0 + 1
    ____obj[____index] = ____obj[____index] - 1
end
function copiedObjectHasChildObject(self)
    local childObjectIndex = "abc"
    local keyToLookFor = "def"
    local valueToLookFor = "ghi"
    local oldObject = {abc = {def = valueToLookFor}}
    local newTable = deepCopy(nil, oldObject)
    local newObject = newTable
    local childObject = newObject[childObjectIndex]
    if childObject == nil then
        error("Failed to find the child object at index: " .. childObjectIndex)
    end
    local childObjectType = type(childObject)
    if childObjectType ~= "table" then
        error("The copied child object was not a table.")
    end
    local value = childObject[keyToLookFor]
    if value == nil then
        error("The child object did not have a key of: " .. keyToLookFor)
    end
    local valueType = type(value)
    if valueType ~= "string" then
        error("The child object value had a type of: " .. valueType)
    end
    if value ~= valueToLookFor then
        error("The child object value was: " .. valueToLookFor)
    end
end
function copiedMapIsMap(self)
    local keyToLookFor = "abc"
    local valueToLookFor = "def"
    local oldMap = __TS__New(Map)
    oldMap:set(keyToLookFor, valueToLookFor)
    local newObject = deepCopy(nil, oldMap)
    local newMap = newObject
    local newMapType = type(newMap)
    if newMapType ~= "table" then
        error("The copied Map was not a table.")
    end
    if not __TS__InstanceOf(newMap, Map) then
        error("The copied Map was not a Map.")
    end
end
function copiedMapHasValue(self)
    local keyToLookFor = "abc"
    local valueToLookFor = "def"
    local oldMap = __TS__New(Map)
    oldMap:set(keyToLookFor, valueToLookFor)
    local newTable = deepCopy(nil, oldMap)
    local newMap = newTable
    local value = newMap:get(keyToLookFor)
    if value == nil then
        error("The copied Map did not have a key of: " .. keyToLookFor)
    end
    if value ~= valueToLookFor then
        error("The copied Map did not have a value of: " .. valueToLookFor)
    end
end
function copiedSetIsSet(self)
    local valueToLookFor = "abc"
    local oldSet = __TS__New(Set)
    oldSet:add(valueToLookFor)
    local newTable = deepCopy(nil, oldSet)
    local newSet = newTable
    local newSetType = type(newSet)
    if newSetType ~= "table" then
        error("The copied Set was not a table.")
    end
    if not __TS__InstanceOf(newSet, Set) then
        error("The copied Set was not a Map.")
    end
end
function copiedSetHasValue(self)
    local valueToLookFor = "abc"
    local oldSet = __TS__New(Set)
    oldSet:add(valueToLookFor)
    local newTable = deepCopy(nil, oldSet)
    local newSet = newTable
    local hasValue = newSet:has(valueToLookFor)
    if not hasValue then
        error("The copied Set did not have a value of: " .. valueToLookFor)
    end
end
function copiedMapHasChildMap(self)
    local childMapKey = 123
    local childMapValue = 456
    local oldChildMap = __TS__New(Map)
    oldChildMap:set(childMapKey, childMapValue)
    local keyToLookFor = "abc"
    local oldMap = __TS__New(Map)
    oldMap:set(keyToLookFor, oldChildMap)
    local newTable = deepCopy(nil, oldMap)
    local newMap = newTable
    local newChildMap = newMap:get(keyToLookFor)
    if newChildMap == nil then
        error("The copied Map did not have a child map at key: " .. keyToLookFor)
    end
    local newChildMapType = type(newChildMap)
    if newChildMapType ~= "table" then
        error("The copied child Map had a type of: " .. newChildMapType)
    end
    if not __TS__InstanceOf(newChildMap, Map) then
        error("The copied child Map was not a Map.")
    end
    local value = newChildMap:get(childMapKey)
    if value == nil then
        error(
            "The copied child Map did not have a key of: " .. tostring(childMapKey)
        )
    end
    if value ~= childMapValue then
        error(
            "The copied child Map did not have a value of: " .. tostring(childMapValue)
        )
    end
end
function ____exports.deepCopyTests(self)
    copiedObjectIsTable(nil)
    copiedObjectHasKeyAndValueString(nil)
    copiedTableHasKeyAndValueNumber(nil)
    copiedTableDoesNotCoerceTypes(nil)
    copiedObjectHasNoReferencesForPrimitivesForward(nil)
    copiedObjectHasNoReferencesForPrimitivesBackward(nil)
    copiedObjectHasNoReferencesForArray(nil)
    copiedObjectHasChildObject(nil)
    copiedMapIsMap(nil)
    copiedMapHasValue(nil)
    copiedSetIsSet(nil)
    copiedSetHasValue(nil)
    copiedMapHasChildMap(nil)
    log(nil, "All tests passed!")
end
return ____exports
