"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../constants");
const file = __importStar(require("../../file"));
const misc_1 = require("../../misc");
const copy_1 = require("../copy/copy");
function publish(argv, config) {
    const skip = argv.skip === true;
    const setVersion = argv.setversion;
    const modTargetPath = path_1.default.join(config.modsDirectory, constants_1.CURRENT_DIRECTORY_NAME);
    if (setVersion !== undefined && /^\d+\.\d+\.\d+$/.exec(setVersion) === null) {
        misc_1.error(chalk_1.default.red(`The version of "${setVersion}" does not match the semantic versioning format.`));
    }
    startPublish(constants_1.MOD_SOURCE_PATH, modTargetPath, skip, setVersion, config.steamCmdPath);
}
exports.default = publish;
function startPublish(modSourcePath, modTargetPath, skip, setVersion, steamCmdPath) {
    updateDeps();
    let version = setVersion === undefined ? getVersionFromPackageJSON() : setVersion;
    if (!skip && setVersion === undefined) {
        version = bumpVersionInPackageJSON(version);
    }
    else if (setVersion !== undefined) {
        writeVersionInPackageJSON(version);
    }
    writeVersionToConstantsTS(version);
    writeVersionToMetadataXML(version);
    writeVersionToVersionTXT(version);
    runReleaseScriptPreCopy();
    copy_1.compileAndCopy(modSourcePath, modTargetPath);
    purgeRoomXMLs(modTargetPath);
    runReleaseScriptPostCopy();
    gitCommitIfChanges(version);
    uploadMod(modTargetPath, steamCmdPath);
    console.log(`\nPublished version ${version} successfully.`);
}
function updateDeps() {
    misc_1.execShell("npx", [
        "npm-check-updates",
        "--upgrade",
        "--packageFile",
        "package.json",
    ]);
    console.log("NPM dependencies updated successfully.");
}
function getVersionFromPackageJSON() {
    if (!file.exists(constants_1.PACKAGE_JSON_PATH)) {
        misc_1.error(chalk_1.default.red(`A "${constants_1.PACKAGE_JSON_PATH}" was not found in the current directory.`));
    }
    const packageJSONRaw = file.read(constants_1.PACKAGE_JSON_PATH);
    let packageJSON;
    try {
        packageJSON = JSON.parse(packageJSONRaw);
    }
    catch (err) {
        misc_1.error(`Failed to parse "${chalk_1.default.green(constants_1.PACKAGE_JSON_PATH)}":`, err);
    }
    if (!Object.prototype.hasOwnProperty.call(packageJSON, "version")) {
        misc_1.error(`The "${chalk_1.default.green(constants_1.PACKAGE_JSON_PATH)}" file does not have a "version" field.`);
    }
    if (typeof packageJSON.version !== "string") {
        misc_1.error(`The "${chalk_1.default.green(constants_1.PACKAGE_JSON_PATH)}" file has a "version" field that is not a string.`);
    }
    return packageJSON.version;
}
function bumpVersionInPackageJSON(version) {
    // Get the patch version (i.e. the third number)
    const matches = /(\d+\.\d+\.)(\d+)/.exec(version);
    if (matches === null) {
        misc_1.error(`Failed to parse the version of: ${version}`);
    }
    const versionPrefix = matches[1];
    if (versionPrefix === undefined) {
        misc_1.error(`Failed to parse the first part of the version: ${version}`);
    }
    const patchVersionString = matches[2];
    if (patchVersionString === undefined) {
        misc_1.error(`Failed to parse the second part of the version: ${version}`);
    }
    const patchVersion = misc_1.parseIntSafe(patchVersionString);
    if (Number.isNaN(patchVersion)) {
        misc_1.error(`Failed to convert "${patchVersionString}" to a number.`);
    }
    const incrementedPatchVersion = patchVersion + 1;
    const incrementedVersion = `${versionPrefix}${incrementedPatchVersion}`;
    const packageJSON = file.read(constants_1.PACKAGE_JSON_PATH);
    const newPackageJSON = packageJSON.replace(/"version": ".+",/, `"version": "${incrementedVersion}",`);
    file.write(constants_1.PACKAGE_JSON_PATH, newPackageJSON);
    console.log(`The version of ${incrementedVersion} was written to: ${constants_1.PACKAGE_JSON_PATH}`);
    return incrementedVersion;
}
function writeVersionInPackageJSON(version) {
    const packageJSON = file.read(constants_1.PACKAGE_JSON_PATH);
    const newPackageJSON = packageJSON.replace(/"version": ".+",/, `"version": "${version}",`);
    file.write(constants_1.PACKAGE_JSON_PATH, newPackageJSON);
    console.log(`The version of ${version} was written to: ${constants_1.PACKAGE_JSON_PATH}`);
}
function writeVersionToConstantsTS(version) {
    if (!file.exists(constants_1.CONSTANTS_TS_PATH)) {
        console.log('Skipping writing the version to "constants.ts" since it was not found.');
        return;
    }
    const constantsTS = file.read(constants_1.CONSTANTS_TS_PATH);
    const newConstantsTS = constantsTS.replace(/const VERSION = ".+"/, `const VERSION = "${version}"`);
    file.write(constants_1.CONSTANTS_TS_PATH, newConstantsTS);
    console.log(`The version of ${version} was written to: ${constants_1.CONSTANTS_TS_PATH}`);
}
function writeVersionToMetadataXML(version) {
    const metadataXML = file.read(constants_1.METADATA_XML_PATH);
    const newMetadataXML = metadataXML.replace(/<version>.+<\/version>/, `<version>${version}</version>`);
    file.write(constants_1.METADATA_XML_PATH, newMetadataXML);
    console.log(`The version of ${version} was written to: ${constants_1.METADATA_XML_PATH}`);
}
function writeVersionToVersionTXT(version) {
    file.write(constants_1.VERSION_TXT_PATH, version);
    console.log(`The version of ${version} was written to: ${constants_1.VERSION_TXT_PATH}`);
}
function runReleaseScriptPreCopy() {
    if (!file.exists(constants_1.PUBLISH_PRE_COPY_PY_PATH)) {
        return;
    }
    console.log(`Running the "${constants_1.PUBLISH_PRE_COPY_PY_PATH}" script.`);
    misc_1.execShell("python", [constants_1.PUBLISH_PRE_COPY_PY_PATH]);
}
function runReleaseScriptPostCopy() {
    if (!file.exists(constants_1.PUBLISH_POST_COPY_PY_PATH)) {
        return;
    }
    console.log(`Running the "${constants_1.PUBLISH_POST_COPY_PY_PATH}" script.`);
    misc_1.execShell("python", [constants_1.PUBLISH_POST_COPY_PY_PATH]);
}
function gitCommitIfChanges(version) {
    // Throw an error if this is not a git repository
    misc_1.execShell("git", ["status"]);
    // Check to see if there are any changes
    // https://stackoverflow.com/questions/3878624/how-do-i-programmatically-determine-if-there-are-uncommitted-changes
    const [exitCode] = misc_1.execShell("git", ["diff-index", "--quiet", "HEAD", "--"], true);
    if (exitCode === 0) {
        // There are no changes
        console.log("There are no changes to commit.");
        return;
    }
    const commitMessage = `v${version}`;
    misc_1.execShell("git", ["add", "-A"]);
    misc_1.execShell("git", ["commit", "-m", commitMessage]);
    misc_1.execShell("git", ["push"]);
    console.log(`Committed and pushed to the git repository with a message of: ${commitMessage}`);
}
function purgeRoomXMLs(modTargetPath) {
    const roomsPath = path_1.default.join(modTargetPath, "resources", "rooms");
    if (!file.exists(roomsPath) || !file.isDir(roomsPath)) {
        return;
    }
    const roomFileList = file.getDirList(roomsPath);
    roomFileList.forEach((fileName) => {
        if (path_1.default.extname(fileName) === ".xml") {
            const roomFilePath = path_1.default.join(roomsPath, fileName);
            file.deleteFile(roomFilePath);
        }
    });
}
function uploadMod(modTargetPath, steamCmdPath) {
    if (steamCmdPath === undefined) {
        misc_1.error(`In order for IsaacScript to automatically upload a mod, it needs to know the path to the "steamcmd.exe" program on your computer. Add a "${chalk_1.default.green("steamCmdPath")}" property to your "${chalk_1.default.green(constants_1.CONFIG_FILE_NAME)}" file and try again.`);
    }
    if (!file.exists(steamCmdPath)) {
        misc_1.error(chalk_1.default.red(`The path provided for "steamCmdPath" is "${steamCmdPath}", but that does not exist.`));
    }
    const metadataVDFPath = path_1.default.join(modTargetPath, "metadata.vdf");
    if (!file.exists(metadataVDFPath)) {
        console.error(chalk_1.default.red('A "metadata.vdf" file was not found in your mod directory. You must create this file in order for "steamcmd.exe" to work. Please see the IsaacScript docs:'));
        misc_1.error(getIsaacScriptDocs());
    }
    const usernameVar = "STEAM_USERNAME";
    const username = process.env[usernameVar];
    if (username === undefined || username === "") {
        console.error(chalk_1.default.red(`Failed to read the "${usernameVar}" environment variable from the ".env" file. Please see the IsaacScript docs:`));
        misc_1.error(getIsaacScriptDocs());
    }
    const passwordVar = "STEAM_PASSWORD";
    const password = process.env[passwordVar];
    if (password === undefined || password === "") {
        console.error(chalk_1.default.red(`Failed to read the "${passwordVar}" environment variable from the ".env" file. Please see the IsaacScript docs:`));
        misc_1.error(getIsaacScriptDocs());
    }
    console.log("Uploading the mod to the Steam Workshop...");
    misc_1.execShell(steamCmdPath, [
        "+login",
        username,
        password,
        "+workshop_build_item",
        metadataVDFPath,
        "+quit",
    ]);
    console.log("Mod uploaded successfully.");
}
function getIsaacScriptDocs() {
    return chalk_1.default.red("https://isaacscript.github.io/docs/publishing-to-the-workshop/#metadatavdf");
}
//# sourceMappingURL=publish.js.map