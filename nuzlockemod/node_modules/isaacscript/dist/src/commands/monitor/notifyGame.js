"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ping = exports.command = exports.msg = void 0;
const chalk_1 = __importDefault(require("chalk"));
const misc_1 = require("../../misc");
const spawnSaveDatWriter_1 = require("./spawnSaveDatWriter");
function msg(data) {
    const formattedData = data
        .replace(/\r\n/g, "\n") // Replace Windows newlines with Unix newlines
        .trim(); // Trim whitespace
    for (const line of formattedData.split("\n")) {
        const trimmedLine = line.trim();
        if (trimmedLine === "") {
            continue;
        }
        // Ignore the final message from tstl upon exiting the program
        if (trimmedLine === "Terminate batch job (Y/N)?") {
            return;
        }
        // Add a time prefix
        const formattedLine = `[${misc_1.getTime()}] ${trimmedLine}`;
        spawnSaveDatWriter_1.sendMsgToSaveDatWriter({
            type: "msg",
            data: formattedLine,
        });
        // We also print the message to standard out so that the end-user can choose between reading
        // tstl errors from the IsaacScript terminal window or from looking at the in-game output
        printMsgToStandardOut(formattedLine);
    }
}
exports.msg = msg;
function printMsgToStandardOut(data) {
    let coloredData = data;
    if (data.match(/Compilation successful./g) !== null) {
        coloredData = chalk_1.default.green(data);
    }
    else if (data.match(/error/g) !== null) {
        coloredData = chalk_1.default.red(data);
    }
    console.log(coloredData);
}
function command(data) {
    spawnSaveDatWriter_1.sendMsgToSaveDatWriter({
        type: "command",
        data,
    });
}
exports.command = command;
function ping() {
    spawnSaveDatWriter_1.sendMsgToSaveDatWriter({
        type: "ping",
        data: "",
    });
}
exports.ping = ping;
//# sourceMappingURL=notifyGame.js.map